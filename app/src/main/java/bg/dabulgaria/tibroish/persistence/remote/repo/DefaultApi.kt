///**
//* Ti Broish API
//* Ti Broish API is built for clients sending in election results data in Bulgaria
//*
//* OpenAPI spec version: 0.1
//* Contact: team@dabulgaria.bg
//*
//* NOTE: This class is auto generated by the swagger code generator program.
//* https://github.com/swagger-api/swagger-codegen.git
//* Do not edit the class manually.
//*/
//package bg.dabulgaria.tibroish.persistence.api
//
//import bg.dabulgaria.tibroish.persistence.remote.model.BroadcastDto
//import bg.dabulgaria.tibroish.persistence.remote.model.ClientDto
//import bg.dabulgaria.tibroish.persistence.remote.model.ElectionRegionDto
//import bg.dabulgaria.tibroish.domain.organisation.OrganizationDto
//import bg.dabulgaria.tibroish.persistence.remote.model.PartyDto
//import bg.dabulgaria.tibroish.persistence.remote.model.PictureDto
//import bg.dabulgaria.tibroish.persistence.remote.model.PostDto
//import bg.dabulgaria.tibroish.persistence.remote.model.ProtocolDto
//import bg.dabulgaria.tibroish.persistence.remote.model.ProtocolResultsDto
//import bg.dabulgaria.tibroish.persistence.remote.model.StreamDto
//import bg.dabulgaria.tibroish.persistence.remote.model.UploadImageDto
//import bg.dabulgaria.tibroish.persistence.remote.model.UserDto
//import bg.dabulgaria.tibroish.persistence.remote.model.ViolationCommentDto
//import bg.dabulgaria.tibroish.persistence.remote.model.ViolationDto
//
//import org.openapitools.client.infrastructure.ApiClient
//import org.openapitools.client.infrastructure.ClientException
//import org.openapitools.client.infrastructure.ClientError
//import org.openapitools.client.infrastructure.ServerException
//import org.openapitools.client.infrastructure.ServerError
//import org.openapitools.client.infrastructure.MultiValueMap
//import org.openapitools.client.infrastructure.RequestConfig
//import org.openapitools.client.infrastructure.RequestMethod
//import org.openapitools.client.infrastructure.ResponseType
//import org.openapitools.client.infrastructure.Success
//import kotlin.jvm.Throws
//
//class DefaultApi(basePath: kotlin.String = defaultBasePath) : ApiClient(basePath) {
//    companion object {
//        @JvmStatic
//        val defaultBasePath: String by lazy {
//            System.getProperties().getProperty("org.openapitools.client.baseUrl", "http://localhost")
//        }
//    }
//
//    /**
//    *
//    *
//    * @param broadcastDto
//    * @return BroadcastDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun broadcastsCreate(broadcastDto: BroadcastDto) : BroadcastDto {
//        val localVariableBody: kotlin.Any? = broadcastDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/broadcasts",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<BroadcastDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as BroadcastDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return kotlin.collections.List<BroadcastDto>
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun broadcastsIndex() : kotlin.collections.List<BroadcastDto> {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/broadcasts",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.collections.List<BroadcastDto>>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<BroadcastDto>
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun countriesIndex() : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/countries",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return kotlin.collections.List<ElectionRegionDto>
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun electionRegionsIndex() : kotlin.collections.List<ElectionRegionDto> {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/election_regions",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.collections.List<ElectionRegionDto>>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ElectionRegionDto>
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param clientDto
//    * @return ClientDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun meClientsCreate(clientDto: ClientDto) : ClientDto {
//        val localVariableBody: kotlin.Any? = clientDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/me/clients",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<ClientDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as ClientDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return kotlin.collections.List<ClientDto>
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun meClientsIndex() : kotlin.collections.List<ClientDto> {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/me/clients",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.collections.List<ClientDto>>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ClientDto>
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun meDelete() : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.DELETE,
//            "/me",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return UserDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun meGet() : UserDto {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/me",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<UserDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as UserDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param userDto
//    * @return UserDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun mePatch(userDto: UserDto) : UserDto {
//        val localVariableBody: kotlin.Any? = userDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.PATCH,
//            "/me",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<UserDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as UserDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return kotlin.collections.List<ProtocolDto>
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun meProtocolsIndex() : kotlin.collections.List<ProtocolDto> {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/me/protocols",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.collections.List<ProtocolDto>>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ProtocolDto>
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun meStreamStream() : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/me/stream",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun meStreamStreamStart() : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/me/stream/start",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun meStreamStreamStop() : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/me/stream/stop",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return kotlin.collections.List<ViolationDto>
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun meViolationIndex() : kotlin.collections.List<ViolationDto> {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/me/violations",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.collections.List<ViolationDto>>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<ViolationDto>
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return kotlin.collections.List<OrganizationDto>
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun organizationsIndex() : kotlin.collections.List<OrganizationDto> {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/organizations",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.collections.List<OrganizationDto>>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<OrganizationDto>
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return kotlin.collections.List<PartyDto>
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun partiesIndex() : kotlin.collections.List<PartyDto> {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/parties",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.collections.List<PartyDto>>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PartyDto>
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @return PictureDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun picturesGet(id: kotlin.String) : PictureDto {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/pictures/{id}".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<PictureDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as PictureDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param uploadImageDto
//    * @return PictureDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun picturesUploadFile(uploadImageDto: UploadImageDto) : PictureDto {
//        val localVariableBody: kotlin.Any? = uploadImageDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/pictures",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<PictureDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as PictureDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param postDto
//    * @return PostDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun postsCreate(postDto: PostDto) : PostDto {
//        val localVariableBody: kotlin.Any? = postDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/posts",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<PostDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as PostDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return kotlin.collections.List<PostDto>
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun postsIndex() : kotlin.collections.List<PostDto> {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/posts",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.collections.List<PostDto>>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<PostDto>
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param protocol
//    * @param userDto
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolAssigneesAddAssignee(protocol: kotlin.String, userDto: UserDto) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = userDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/protocols/{protocol}/assignees".replace("{"+"protocol"+"}", "$protocol"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param protocol
//    * @param assignee
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolAssigneesDeleteAssignee(protocol: kotlin.String, assignee: kotlin.String) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.DELETE,
//            "/protocols/{protocol}/assignees/{assignee}".replace("{"+"protocol"+"}", "$protocol").replace("{"+"assignee"+"}", "$assignee"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param protocol
//    * @return kotlin.collections.List<UserDto>
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolAssigneesGetAssignees(protocol: kotlin.String) : kotlin.collections.List<UserDto> {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/protocols/{protocol}/assignees".replace("{"+"protocol"+"}", "$protocol"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.collections.List<UserDto>>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UserDto>
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param protocol
//    * @param requestBody
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolAssigneesPutAssignees(protocol: kotlin.String, requestBody: kotlin.collections.List<kotlin.String>) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = requestBody
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.PUT,
//            "/protocols/{protocol}/assignees".replace("{"+"protocol"+"}", "$protocol"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolsApprove(id: kotlin.String) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/protocols/{id}/approve".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolsApproveNotify(id: kotlin.String) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/protocols/{id}/approve-with-violation".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return ProtocolDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolsAssign() : ProtocolDto {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/protocols/assign",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<ProtocolDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as ProtocolDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param protocolDto
//    * @return ProtocolDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolsCreate(protocolDto: ProtocolDto) : ProtocolDto {
//        val localVariableBody: kotlin.Any? = protocolDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/protocols",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<ProtocolDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as ProtocolDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @param protocolResultsDto
//    * @return ProtocolResultsDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolsCreateResults(id: kotlin.String, protocolResultsDto: ProtocolResultsDto) : ProtocolResultsDto {
//        val localVariableBody: kotlin.Any? = protocolResultsDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/protocols/{id}/results".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<ProtocolResultsDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as ProtocolResultsDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @return ProtocolDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolsGet(id: kotlin.String) : ProtocolDto {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/protocols/{id}".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<ProtocolDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as ProtocolDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param page
//    * @param assignee
//    * @param section
//    * @param status
//    * @param author
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolsIndex(page: java.math.BigDecimal, assignee: kotlin.String, section: kotlin.String, status: kotlin.String, author: kotlin.String) : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
//            .apply {
//                put("page", listOf(page.toString()))
//                put("assignee", listOf(assignee.toString()))
//                put("section", listOf(section.toString()))
//                put("status", listOf(status.toString()))
//                put("author", listOf(author.toString()))
//            }
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/protocols",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolsReject(id: kotlin.String) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/protocols/{id}/reject".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @param protocolDto
//    * @return ProtocolDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolsReplace(id: kotlin.String, protocolDto: ProtocolDto) : ProtocolDto {
//        val localVariableBody: kotlin.Any? = protocolDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/protocols/{id}/replace".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<ProtocolDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as ProtocolDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @return ProtocolResultsDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun protocolsResults(id: kotlin.String) : ProtocolResultsDto {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/protocols/{id}/results".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<ProtocolResultsDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as ProtocolResultsDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun resultsIndex() : kotlin.Any {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/results/index.json",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun resultsMeta() : kotlin.Any {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/results/meta.json",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param segment
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun resultsSubset(segment: kotlin.String) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/results/{segment}.json".replace("{"+"segment"+"}", "$segment"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param section
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun sectionsGet(section: kotlin.String) : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/sections/{section}".replace("{"+"section"+"}", "$section"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param town The town code to filter by
//    * @param cityRegion The city region code to filter by (optional)
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun sectionsQuery(town: java.math.BigDecimal, cityRegion: kotlin.String?) : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
//            .apply {
//                put("town", listOf(town.toString()))
//                if (cityRegion != null) {
//                    put("city_region", listOf(cityRegion.toString()))
//                }
//            }
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/sections",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param streamDto
//    * @return StreamDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun streamsCreate(streamDto: StreamDto) : StreamDto {
//        val localVariableBody: kotlin.Any? = streamDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/streams",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<StreamDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as StreamDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param country The country code to filter by
//    * @param electionRegion The election region code to filter by (optional)
//    * @param municipality The municipality code to filter by (optional)
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun townsQuery(country: kotlin.String, electionRegion: kotlin.String?, municipality: kotlin.String?) : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
//            .apply {
//                put("country", listOf(country.toString()))
//                if (electionRegion != null) {
//                    put("election_region", listOf(electionRegion.toString()))
//                }
//                if (municipality != null) {
//                    put("municipality", listOf(municipality.toString()))
//                }
//            }
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/towns",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param userDto
//    * @return UserDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun usersCreate(userDto: UserDto) : UserDto {
//        val localVariableBody: kotlin.Any? = userDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/users",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<UserDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as UserDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @return UserDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun usersGet(id: kotlin.String) : UserDto {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/users/{id}".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<UserDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as UserDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param page
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun usersIndex(page: java.math.BigDecimal) : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
//            .apply {
//                put("page", listOf(page.toString()))
//            }
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/users",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @param userDto
//    * @return UserDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun usersUpdate(id: kotlin.String, userDto: UserDto) : UserDto {
//        val localVariableBody: kotlin.Any? = userDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.PATCH,
//            "/users/{id}".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<UserDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as UserDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param violation
//    * @param userDto
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationAssigneesAddAssignee(violation: kotlin.String, userDto: UserDto) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = userDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/violations/{violation}/assignees".replace("{"+"violation"+"}", "$violation"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param violation
//    * @param assignee
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationAssigneesDeleteAssignee(violation: kotlin.String, assignee: kotlin.String) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.DELETE,
//            "/violations/{violation}/assignees/{assignee}".replace("{"+"violation"+"}", "$violation").replace("{"+"assignee"+"}", "$assignee"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param violation
//    * @return kotlin.collections.List<UserDto>
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationAssigneesGetAssignees(violation: kotlin.String) : kotlin.collections.List<UserDto> {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/violations/{violation}/assignees".replace("{"+"violation"+"}", "$violation"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.collections.List<UserDto>>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<UserDto>
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param violation
//    * @param requestBody
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationAssigneesPutAssignees(violation: kotlin.String, requestBody: kotlin.collections.List<kotlin.String>) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = requestBody
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.PUT,
//            "/violations/{violation}/assignees".replace("{"+"violation"+"}", "$violation"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param violation
//    * @param violationCommentDto
//    * @return ViolationCommentDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationCommentsCreate(violation: kotlin.String, violationCommentDto: ViolationCommentDto) : ViolationCommentDto {
//        val localVariableBody: kotlin.Any? = violationCommentDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/violations/{violation}/comments".replace("{"+"violation"+"}", "$violation"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<ViolationCommentDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as ViolationCommentDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param page
//    * @param violation
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationCommentsIndex(page: java.math.BigDecimal, violation: kotlin.String) : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
//            .apply {
//                put("page", listOf(page.toString()))
//            }
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/violations/{violation}/comments".replace("{"+"violation"+"}", "$violation"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param violationDto
//    * @return ViolationDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationsCreate(violationDto: ViolationDto) : ViolationDto {
//        val localVariableBody: kotlin.Any? = violationDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/violations",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<ViolationDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as ViolationDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @return ViolationDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationsGet(id: kotlin.String) : ViolationDto {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/violations/{id}".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<ViolationDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as ViolationDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param page
//    * @param assignee
//    * @param section
//    * @param status
//    * @param author
//    * @param town
//    * @param organization
//    * @return void
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationsIndex(page: java.math.BigDecimal, assignee: kotlin.String, section: kotlin.String, status: kotlin.String, author: kotlin.String, town: kotlin.String, organization: java.math.BigDecimal) : Unit {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, List<kotlin.String>>()
//            .apply {
//                put("page", listOf(page.toString()))
//                put("assignee", listOf(assignee.toString()))
//                put("section", listOf(section.toString()))
//                put("status", listOf(status.toString()))
//                put("author", listOf(author.toString()))
//                put("town", listOf(town.toString()))
//                put("organization", listOf(organization.toString()))
//            }
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.GET,
//            "/violations",
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<Any?>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> Unit
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @param violationDto
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationsPatch(id: kotlin.String, violationDto: ViolationDto) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = violationDto
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.PATCH,
//            "/violations/{id}".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @return kotlin.Any
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationsProcess(id: kotlin.String) : kotlin.Any {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/violations/{id}/process".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<kotlin.Any>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//    /**
//    *
//    *
//    * @param id
//    * @return ViolationDto
//    * @throws UnsupportedOperationException If the API returns an informational or redirection response
//    * @throws ClientException If the API returns a client error response
//    * @throws ServerException If the API returns a server error response
//    */
//    @Suppress("UNCHECKED_CAST")
//    @Throws(UnsupportedOperationException::class, ClientException::class, ServerException::class)
//    fun violationsReject(id: kotlin.String) : ViolationDto {
//        val localVariableBody: kotlin.Any? = null
//        val localVariableQuery: MultiValueMap = mutableMapOf()
//        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
//        val localVariableConfig = RequestConfig(
//            RequestMethod.POST,
//            "/violations/{id}/reject".replace("{"+"id"+"}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders
//        )
//        val localVarResponse = request<ViolationDto>(
//            localVariableConfig,
//            localVariableBody
//        )
//
//        return when (localVarResponse.responseType) {
//            ResponseType.Success -> (localVarResponse as Success<*>).data as ViolationDto
//            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
//            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
//            ResponseType.ClientError -> {
//                val localVarError = localVarResponse as ClientError<*>
//                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//            ResponseType.ServerError -> {
//                val localVarError = localVarResponse as ServerError<*>
//                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
//            }
//        }
//    }
//
//}
